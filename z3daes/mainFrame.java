/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * mainFrame.java
 *
 * Created on Aug 9, 2011, 9:46:31 AM by Suriyani Ariffin
 */
package z3daes;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JPanel;

class MyCustomFilter extends javax.swing.filechooser.FileFilter {

    @Override
    public boolean accept(File file) {
        // Allow only directories, or files with ".txt" extension
        return file.isDirectory() || file.getAbsolutePath().endsWith(".txt");
    }

    @Override
    public String getDescription() {
        // This description will be displayed in the dialog,
        // hard-coded = ugly, should be done via I18N
        return "Text documents (*.txt)";
    }
}

class dImage extends JPanel {

    BufferedImage image;

    dImage(BufferedImage image) {
        this.image = image;
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.drawImage(image, 0, 0, this);
    }
}

/**
 *
 * @author suriyani
 */
public class mainFrame extends javax.swing.JFrame {
    //private Object buttonGroup1;

    private String outputFile = "";
    private String tempKeyD = "",  tempCodeD = "",  outputc = "",  outputh = "";
    int tabFlag = 0;
    //private String outputc = "";
    //private String outputFileDe = "";

    /** Creates new form mainFrame */
    public mainFrame() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        buttonGroup4 = new javax.swing.ButtonGroup();
        inputFileTab = new javax.swing.JTabbedPane();
        inputTextPanel = new javax.swing.JPanel();
        inPLPane = new javax.swing.JLayeredPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        inPTextArea = new javax.swing.JTextArea();
        inStartButton = new javax.swing.JButton();
        inKLPane = new javax.swing.JLayeredPane();
        inKTextField = new javax.swing.JTextField();
        inRotateLPane = new javax.swing.JLayeredPane();
        xAxisRadioButton = new javax.swing.JRadioButton();
        yAxisRadioButton = new javax.swing.JRadioButton();
        zAxisRadioButton = new javax.swing.JRadioButton();
        inFLPane = new javax.swing.JLayeredPane();
        inEnRadioButton = new javax.swing.JRadioButton();
        inDeRadioButton = new javax.swing.JRadioButton();
        inEnLPane = new javax.swing.JLayeredPane();
        jScrollPane3 = new javax.swing.JScrollPane();
        inEnTextArea = new javax.swing.JTextArea();
        inClearButton = new javax.swing.JButton();
        inDeLPane = new javax.swing.JLayeredPane();
        jScrollPane4 = new javax.swing.JScrollPane();
        inDeTextArea = new javax.swing.JTextArea();
        inExitButton = new javax.swing.JButton();
        inProgressLPane = new javax.swing.JLayeredPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        inProgressTextArea = new javax.swing.JTextArea();
        jScrollPane8 = new javax.swing.JScrollPane();
        inTempTextArea = new javax.swing.JTextArea();
        inputFilePanel = new javax.swing.JPanel();
        fPLPane = new javax.swing.JLayeredPane();
        fBrowseButton = new javax.swing.JButton();
        fBrowseTextField = new javax.swing.JTextField();
        fFileNameLabel = new javax.swing.JLabel();
        fFileChooser = new javax.swing.JFileChooser();
        fKeyNameLabel = new javax.swing.JLabel();
        fKBrowseTextField = new javax.swing.JTextField();
        fKBrowseButton = new javax.swing.JButton();
        fKMsgLabel = new javax.swing.JTextField();
        fPMsgLabel = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        fFLPane = new javax.swing.JLayeredPane();
        fEnRadioButton = new javax.swing.JRadioButton();
        fDeRadioButton = new javax.swing.JRadioButton();
        fRotateLPane1 = new javax.swing.JLayeredPane();
        fxAxisRadioButton = new javax.swing.JRadioButton();
        fyAxisRadioButton = new javax.swing.JRadioButton();
        fzAxisRadioButton = new javax.swing.JRadioButton();
        fStartButton = new javax.swing.JButton();
        fClearButton = new javax.swing.JButton();
        fExitButton = new javax.swing.JButton();
        fProgressLPane = new javax.swing.JLayeredPane();
        jScrollPane5 = new javax.swing.JScrollPane();
        fProgressTextArea = new javax.swing.JTextArea();
        fCLPane = new javax.swing.JLayeredPane();
        fEnSaveButton = new javax.swing.JButton();
        fEnTextField = new javax.swing.JTextField();
        fEnNameLabel = new javax.swing.JLabel();
        fEnSaveButtonC = new javax.swing.JButton();
        fEnTextFieldC = new javax.swing.JTextField();
        fEnNameLabelC = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        fPTextArea = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        fKTextArea = new javax.swing.JTextArea();
        jScrollPane9 = new javax.swing.JScrollPane();
        fTempTextArea = new javax.swing.JTextArea();
        helpPanel = new javax.swing.JPanel();
        jScrollPane10 = new javax.swing.JScrollPane();
        helpTextArea = new javax.swing.JTextArea();
        page1Button = new javax.swing.JButton();
        page2Button = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CrytIm ENCRYPTION TOOL");
        setName("mainFrame"); // NOI18N
        setResizable(false);

        inputFileTab.setName("aes"); // NOI18N

        inPLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Plaintext"));
        inPLPane.setName("Plaintext"); // NOI18N

        inPTextArea.setColumns(20);
        inPTextArea.setLineWrap(true);
        inPTextArea.setRows(5);
        jScrollPane1.setViewportView(inPTextArea);

        jScrollPane1.setBounds(10, 20, 680, 80);
        inPLPane.add(jScrollPane1, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inStartButton.setText("Start");
        inStartButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inStartButtonActionPerformed(evt);
            }
        });

        inKLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Secret Key (16 character)"));
        inKTextField.setBounds(10, 20, 680, 30);
        inKLPane.add(inKTextField, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inRotateLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Rotation Axis"));

        buttonGroup2.add(xAxisRadioButton);
        xAxisRadioButton.setSelected(true);
        xAxisRadioButton.setText("X-axis");
        xAxisRadioButton.setActionCommand("xaxis");
        xAxisRadioButton.setBounds(30, 30, 70, 20);
        inRotateLPane.add(xAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup2.add(yAxisRadioButton);
        yAxisRadioButton.setText("Y-axis");
        yAxisRadioButton.setActionCommand("yaxis");
        yAxisRadioButton.setBounds(30, 50, 70, 23);
        inRotateLPane.add(yAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup2.add(zAxisRadioButton);
        zAxisRadioButton.setText("Z-axis");
        zAxisRadioButton.setActionCommand("zaxis");
        zAxisRadioButton.setBounds(30, 70, 70, 23);
        inRotateLPane.add(zAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inFLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Function"));

        buttonGroup1.add(inEnRadioButton);
        inEnRadioButton.setSelected(true);
        inEnRadioButton.setText("Encryption");
        inEnRadioButton.setActionCommand("en");
        inEnRadioButton.setBounds(20, 30, 90, 23);
        inFLPane.add(inEnRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup1.add(inDeRadioButton);
        inDeRadioButton.setText("Decryption");
        inDeRadioButton.setActionCommand("de");
        inDeRadioButton.setBounds(20, 60, 90, 23);
        inFLPane.add(inDeRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inEnLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Encryption/Ciphertext"));

        inEnTextArea.setColumns(20);
        inEnTextArea.setEditable(false);
        inEnTextArea.setLineWrap(true);
        inEnTextArea.setRows(5);
        inEnTextArea.setName("Encryption"); // NOI18N
        inEnTextArea.setVerifyInputWhenFocusTarget(false);
        jScrollPane3.setViewportView(inEnTextArea);
        inEnTextArea.getAccessibleContext().setAccessibleName("en");

        jScrollPane3.setBounds(20, 20, 310, 230);
        inEnLPane.add(jScrollPane3, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inClearButton.setText("Clear");
        inClearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inClearButtonActionPerformed(evt);
            }
        });

        inDeLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Decryption"));

        inDeTextArea.setColumns(20);
        inDeTextArea.setEditable(false);
        inDeTextArea.setLineWrap(true);
        inDeTextArea.setRows(5);
        inDeTextArea.setName("Decryption"); // NOI18N
        jScrollPane4.setViewportView(inDeTextArea);
        inDeTextArea.getAccessibleContext().setAccessibleName("de");

        jScrollPane4.setBounds(20, 20, 330, 230);
        inDeLPane.add(jScrollPane4, javax.swing.JLayeredPane.DEFAULT_LAYER);

        inExitButton.setText("Exit");
        inExitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inExitButtonActionPerformed(evt);
            }
        });

        inProgressLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Decode/Encode Progress"));

        inProgressTextArea.setColumns(20);
        inProgressTextArea.setEditable(false);
        inProgressTextArea.setRows(5);
        jScrollPane2.setViewportView(inProgressTextArea);

        jScrollPane2.setBounds(20, 30, 280, 70);
        inProgressLPane.add(jScrollPane2, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jScrollPane8.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        inTempTextArea.setColumns(20);
        inTempTextArea.setEditable(false);
        inTempTextArea.setRows(5);
        inTempTextArea.setBorder(null);
        jScrollPane8.setViewportView(inTempTextArea);

        javax.swing.GroupLayout inputTextPanelLayout = new javax.swing.GroupLayout(inputTextPanel);
        inputTextPanel.setLayout(inputTextPanelLayout);
        inputTextPanelLayout.setHorizontalGroup(
            inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputTextPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(inKLPane, javax.swing.GroupLayout.DEFAULT_SIZE, 727, Short.MAX_VALUE)
                    .addGroup(inputTextPanelLayout.createSequentialGroup()
                        .addComponent(inFLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(inRotateLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(inProgressLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 319, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(inExitButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(inClearButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(inStartButton, javax.swing.GroupLayout.DEFAULT_SIZE, 75, Short.MAX_VALUE))
                            .addComponent(jScrollPane8, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inputTextPanelLayout.createSequentialGroup()
                        .addComponent(inEnLPane, javax.swing.GroupLayout.DEFAULT_SIZE, 352, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(inDeLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 365, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(inPLPane, javax.swing.GroupLayout.DEFAULT_SIZE, 727, Short.MAX_VALUE))
                .addContainerGap())
        );
        inputTextPanelLayout.setVerticalGroup(
            inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputTextPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(inPLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inKLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(inFLPane, javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(inRotateLPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE))
                    .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, inputTextPanelLayout.createSequentialGroup()
                            .addGap(12, 12, 12)
                            .addComponent(inStartButton)
                            .addGap(12, 12, 12)
                            .addComponent(inClearButton)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(inExitButton)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jScrollPane8, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addComponent(inProgressLPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(8, 8, 8)
                .addGroup(inputTextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(inEnLPane, javax.swing.GroupLayout.DEFAULT_SIZE, 286, Short.MAX_VALUE)
                    .addComponent(inDeLPane, javax.swing.GroupLayout.DEFAULT_SIZE, 286, Short.MAX_VALUE))
                .addContainerGap())
        );

        inputFileTab.addTab("Input From Text", inputTextPanel);

        fPLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Input and Key "));

        fBrowseButton.setText("Browse");
        fBrowseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fBrowseButtonActionPerformed(evt);
            }
        });
        fBrowseButton.setBounds(590, 30, 80, 23);
        fPLPane.add(fBrowseButton, javax.swing.JLayeredPane.DEFAULT_LAYER);
        fBrowseTextField.setBounds(150, 30, 420, 20);
        fPLPane.add(fBrowseTextField, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fFileNameLabel.setText("Plaintext/");
        fFileNameLabel.setBounds(40, 20, 80, 20);
        fPLPane.add(fFileNameLabel, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fFileChooser.setFileFilter(new MyCustomFilter());
        fFileChooser.setBounds(650, 20, 22, 22);
        fPLPane.add(fFileChooser, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fKeyNameLabel.setText("Key file  :");
        fKeyNameLabel.setBounds(40, 70, 50, 30);
        fPLPane.add(fKeyNameLabel, javax.swing.JLayeredPane.DEFAULT_LAYER);
        fKBrowseTextField.setBounds(150, 80, 420, 20);
        fPLPane.add(fKBrowseTextField, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fKBrowseButton.setText("Browse");
        fKBrowseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fKBrowseButtonActionPerformed(evt);
            }
        });
        fKBrowseButton.setBounds(590, 80, 80, 23);
        fPLPane.add(fKBrowseButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fKMsgLabel.setEditable(false);
        fKMsgLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        fKMsgLabel.setBounds(150, 100, 370, 16);
        fPLPane.add(fKMsgLabel, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fPMsgLabel.setEditable(false);
        fPMsgLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        fPMsgLabel.setBounds(150, 50, 370, 16);
        fPLPane.add(fPMsgLabel, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel1.setText("Ciphertext file :");
        jLabel1.setBounds(40, 40, 100, 14);
        fPLPane.add(jLabel1, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fFLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Function"));

        buttonGroup3.add(fEnRadioButton);
        fEnRadioButton.setSelected(true);
        fEnRadioButton.setText("Encryption");
        fEnRadioButton.setActionCommand("en");
        fEnRadioButton.setBounds(20, 40, 90, 23);
        fFLPane.add(fEnRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup3.add(fDeRadioButton);
        fDeRadioButton.setText("Decryption");
        fDeRadioButton.setActionCommand("de");
        fDeRadioButton.setBounds(20, 70, 90, 23);
        fFLPane.add(fDeRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fRotateLPane1.setBorder(javax.swing.BorderFactory.createTitledBorder("Rotation Axis"));

        buttonGroup4.add(fxAxisRadioButton);
        fxAxisRadioButton.setSelected(true);
        fxAxisRadioButton.setText("X-axis");
        fxAxisRadioButton.setActionCommand("xaxis");
        fxAxisRadioButton.setBounds(40, 30, 70, 20);
        fRotateLPane1.add(fxAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup4.add(fyAxisRadioButton);
        fyAxisRadioButton.setText("Y-axis");
        fyAxisRadioButton.setActionCommand("yaxis");
        fyAxisRadioButton.setBounds(40, 50, 70, 23);
        fRotateLPane1.add(fyAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        buttonGroup4.add(fzAxisRadioButton);
        fzAxisRadioButton.setText("Z-axis");
        fzAxisRadioButton.setActionCommand("zaxis");
        fzAxisRadioButton.setBounds(40, 70, 70, 23);
        fRotateLPane1.add(fzAxisRadioButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fStartButton.setText("Start");
        fStartButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fStartButtonActionPerformed(evt);
            }
        });

        fClearButton.setText("Clear");
        fClearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fClearButtonActionPerformed(evt);
            }
        });

        fExitButton.setText("Exit");
        fExitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fExitButtonActionPerformed(evt);
            }
        });

        fProgressLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Decode/Encode Progress"));

        fProgressTextArea.setColumns(20);
        fProgressTextArea.setEditable(false);
        fProgressTextArea.setRows(5);
        jScrollPane5.setViewportView(fProgressTextArea);

        jScrollPane5.setBounds(10, 30, 280, 70);
        fProgressLPane.add(jScrollPane5, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fCLPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Output"));

        fEnSaveButton.setText("Save as");
        fEnSaveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fEnSaveButtonActionPerformed(evt);
            }
        });
        fEnSaveButton.setBounds(590, 80, 80, 23);
        fCLPane.add(fEnSaveButton, javax.swing.JLayeredPane.DEFAULT_LAYER);
        fEnTextField.setBounds(160, 80, 420, 20);
        fCLPane.add(fEnTextField, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fEnNameLabel.setText("Hex format");
        fEnNameLabel.setBounds(40, 80, 100, 20);
        fCLPane.add(fEnNameLabel, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fEnSaveButtonC.setText("Save as");
        fEnSaveButtonC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fEnSaveButtonCActionPerformed(evt);
            }
        });
        fEnSaveButtonC.setBounds(590, 40, 80, 23);
        fCLPane.add(fEnSaveButtonC, javax.swing.JLayeredPane.DEFAULT_LAYER);
        fEnTextFieldC.setBounds(160, 40, 420, 20);
        fCLPane.add(fEnTextFieldC, javax.swing.JLayeredPane.DEFAULT_LAYER);

        fEnNameLabelC.setText("String format");
        fEnNameLabelC.setBounds(40, 40, 100, 20);
        fCLPane.add(fEnNameLabelC, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jScrollPane6.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        fPTextArea.setColumns(20);
        fPTextArea.setRows(5);
        jScrollPane6.setViewportView(fPTextArea);

        jScrollPane7.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        fKTextArea.setColumns(20);
        fKTextArea.setRows(5);
        jScrollPane7.setViewportView(fKTextArea);

        jScrollPane9.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        fTempTextArea.setColumns(20);
        fTempTextArea.setRows(5);
        jScrollPane9.setViewportView(fTempTextArea);

        javax.swing.GroupLayout inputFilePanelLayout = new javax.swing.GroupLayout(inputFilePanel);
        inputFilePanel.setLayout(inputFilePanelLayout);
        inputFilePanelLayout.setHorizontalGroup(
            inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputFilePanelLayout.createSequentialGroup()
                .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inputFilePanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(fFLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(fRotateLPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fProgressLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 298, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(10, 10, 10)
                        .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(fClearButton, javax.swing.GroupLayout.DEFAULT_SIZE, 67, Short.MAX_VALUE)
                            .addComponent(fExitButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inputFilePanelLayout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(fStartButton, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(inputFilePanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(fPLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 685, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(inputFilePanelLayout.createSequentialGroup()
                        .addGap(236, 236, 236)
                        .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(inputFilePanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(fCLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 685, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(42, Short.MAX_VALUE))
            .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(inputFilePanelLayout.createSequentialGroup()
                    .addGap(263, 263, 263)
                    .addComponent(jScrollPane9, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(463, Short.MAX_VALUE)))
        );
        inputFilePanelLayout.setVerticalGroup(
            inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputFilePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(fPLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inputFilePanelLayout.createSequentialGroup()
                        .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(inputFilePanelLayout.createSequentialGroup()
                                .addComponent(fStartButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(fClearButton)
                                .addGap(11, 11, 11)
                                .addComponent(fExitButton)
                                .addGap(13, 13, 13))
                            .addComponent(fRotateLPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)
                            .addComponent(fFLPane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE))
                        .addGap(8, 8, 8))
                    .addComponent(fProgressLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(33, 33, 33)
                .addComponent(fCLPane, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(31, 31, 31)
                .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(111, 111, 111))
            .addGroup(inputFilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inputFilePanelLayout.createSequentialGroup()
                    .addContainerGap(542, Short.MAX_VALUE)
                    .addComponent(jScrollPane9, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(79, 79, 79)))
        );

        inputFileTab.addTab("Input From File", inputFilePanel);

        helpPanel.addAncestorListener(new javax.swing.event.AncestorListener() {
            public void ancestorMoved(javax.swing.event.AncestorEvent evt) {
            }
            public void ancestorAdded(javax.swing.event.AncestorEvent evt) {
                helpPanelAncestorAdded(evt);
            }
            public void ancestorRemoved(javax.swing.event.AncestorEvent evt) {
            }
        });

        helpTextArea.setColumns(20);
        helpTextArea.setEditable(false);
        helpTextArea.setLineWrap(true);
        helpTextArea.setRows(5);
        helpTextArea.setWrapStyleWord(true);
        jScrollPane10.setViewportView(helpTextArea);

        page1Button.setText("Help for Input from text");
        page1Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                page1ButtonActionPerformed(evt);
            }
        });

        page2Button.setText("Help for Input fro file");
        page2Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                page2ButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout helpPanelLayout = new javax.swing.GroupLayout(helpPanel);
        helpPanel.setLayout(helpPanelLayout);
        helpPanelLayout.setHorizontalGroup(
            helpPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(helpPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane10, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(56, 56, 56)
                .addGroup(helpPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(page2Button, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(page1Button, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(258, Short.MAX_VALUE))
        );
        helpPanelLayout.setVerticalGroup(
            helpPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(helpPanelLayout.createSequentialGroup()
                .addGroup(helpPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane10, javax.swing.GroupLayout.PREFERRED_SIZE, 435, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(helpPanelLayout.createSequentialGroup()
                        .addGap(42, 42, 42)
                        .addComponent(page1Button)
                        .addGap(18, 18, 18)
                        .addComponent(page2Button)))
                .addContainerGap(201, Short.MAX_VALUE))
        );

        inputFileTab.addTab("Help", helpPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(inputFileTab, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 742, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(inputFileTab, javax.swing.GroupLayout.DEFAULT_SIZE, 664, Short.MAX_VALUE)
        );

        inputFileTab.getAccessibleContext().setAccessibleName("IMMUNE-INSPIRED BLOCK CIPHER");

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private int[][] S_box = {
        {99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118},
        {202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192},
        {183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21},
        {4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117},
        {9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132},
        {83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207},
        {208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168},
        {81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210},
        {205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115},
        {96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219},
        {224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121},
        {231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8},
        {186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138},
        {112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158},
        {225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223},
        {140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22}
    };
    private int[][] S_box_inverse = {
        {82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251},
        {124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203},
        {84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78},
        {8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37},
        {114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146},
        {108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132},
        {144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6},
        {208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107},
        {58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115},
        {150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110},
        {71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27},
        {252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244},
        {31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95},
        {96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239},
        {160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97},
        {23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125}
    };
    private int[] key = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    private int[][] State = {
        {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}
    };
    private int[][][] sliceState = //{};
            {
        {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
        {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
        {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
        {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
    };
    private int[] extend_key = new int[176];
    private int[] Rcon = {
        0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54
    };

    public void keyGeneration() {
        int KIRALOOPKEY = 0;
        int[] temp = new int[4];

        for (int i = 0; i < 16; i++) {
            extend_key[i] = key[i];
        }

        for (int i = 4; i < 44; i++) {
            for (int j = 0; j < 4; j++) {
                temp[j] = extend_key[(i - 1) * 4 + j];
            }

            if (i % 4 == 0) {
                RotWord(temp);
                for (int j = 0; j < 4; j++) {
                    temp[j] = SubWord(temp[j]);
                    if (j == 0) {
                        temp[j] = temp[j] ^ Rcon[i / 4];
                    }
                }
            }

            for (int j = 0; j < 4; j++) {
                extend_key[(i - 0) * 4 + j] = extend_key[(i - 4) * 4 + j] ^ temp[j];
                KIRALOOPKEY++;
                StringBuffer buf = new StringBuffer(20);
            }
        }
    }

    /*
     * Routate shift left the Array
     */
    public void RotWord(int temp[]) {
        int a;
        a = temp[0];
        temp[0] = temp[1];
        temp[1] = temp[2];
        temp[2] = temp[3];
        temp[3] = a;
    }

    /*
     *	replace the num recording to the S box
     */
    public int SubWord(int a) {
        int x = a / 16;
        int y = a % 16;
        return S_box[x][y];
    }
    /*
     * replace the num recording to the S box 1
     */

    public int SubWord_inverse(int a) {
        int x = a / 16;
        int y = a % 16;
        return S_box_inverse[x][y];
    }

    /*
     * int type transite into Hex
     */
    public String hexFormat(int integer) {
        StringBuffer buf = new StringBuffer(2);

        if (((int) integer & 0xff) < 0x10) {
            buf.append("0");
        }

        buf.append(Long.toString((int) integer & 0xff, 16));
        return buf.toString();
    }

    public String convertHexToString(String hex) {

        StringBuilder sb = new StringBuilder();
        StringBuilder temp = new StringBuilder();

        //49204c6f7665204a617661 split into two characters 49, 20, 4c...
        for (int i = 0; i < hex.length() - 1; i += 2) {

            //grab the hex in pairs
            String output = hex.substring(i, (i + 2));
            //convert hex to decimal
            int decimal = Integer.parseInt(output, 16);
            //convert the decimal to character
            sb.append((char) decimal);

            temp.append(decimal);
        }
        // System.out.println("Decimal : " + temp.toString());

        return sb.toString();
    }

    public String binaryFormat(int integer) {
        StringBuffer buf = new StringBuffer(2);

        if (((int) integer & 0xff) < 0x10) {
            buf.append("");
        }

        buf.append(Integer.toBinaryString(Character.digit(integer, 16)));
        return buf.toString();
    }

    /*
     *function of msgEncrypt
     */
    public void msgEncrypt() {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = extend_key[i] ^ State[k][j];
                i++;
            }
        }

        for (int time = 1; time < 11; time++) {
            roundLoop(time);
        }

    }

    public void roundLoop(int time) {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                State[j][i] = SubWord(State[j][i]);
            }
        }

        // ShiftRow();

        if (time != 10) {
            MixColumn();
        }

        int k = 0;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                State[j][i] = State[j][i] ^ extend_key[time * 16 + k];
                k++;
            }
        }
    }

    public void MixColumn() {
        int[][] temp = new int[4][4];
        for (int i = 0; i < 4; i++) {
            temp[0][i] = Multi(State[0][i], 2) ^ Multi(State[1][i], 3) ^
                    Multi(State[2][i], 1) ^ Multi(State[3][i], 1);
            temp[1][i] = Multi(State[0][i], 1) ^ Multi(State[1][i], 2) ^
                    Multi(State[2][i], 3) ^ Multi(State[3][i], 1);
            temp[2][i] = Multi(State[0][i], 1) ^ Multi(State[1][i], 1) ^
                    Multi(State[2][i], 2) ^ Multi(State[3][i], 3);
            temp[3][i] = Multi(State[0][i], 3) ^ Multi(State[1][i], 1) ^
                    Multi(State[2][i], 1) ^ Multi(State[3][i], 2);
        }
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = temp[k][j];

            }
        }
    }

    public int Multi(int a, int b) {
        int[] temp = new int[8];
        int[] flag = new int[8];
        int c = b;
        for (int i = 0; i < 8; i++) {
            int c1, c2;
            c1 = c / 2;
            c2 = c % 2;
            if (c2 == 1) {
                flag[i] = 1;
            } else {
                flag[i] = 0;
            }
            c = c1;
            if (i == 0) {
                temp[i] = a;
            } else {
                temp[i] = temp[i - 1] * 2;
                if (temp[i] > 255) {
                    temp[i] = (temp[i] % 256) ^ 27;
                }

            }
        }
        a = 0;
        for (int i = 0; i < 8; i++) {
            a = a ^ (temp[i] * flag[i]);
        }

        return a;
    }
    /*
     * function of msgDecrypt
     */

    public void msgDecrypt() {
        int i, j;



        for (int l = 0; l < 4; l++) {
            for (int k = 0; k < 4; k++) {
            }
        }


        for (i = 0            ,j = 160; i < 4; i++) {
            for (int k = 0; k < 4; k++) {
                State[k][i] = extend_key[j] ^ State[k][i];
                j++;
            }
        }

        for (int time = 1; time < 11; time++) {
            roundLoop_inverse(time);
        }
    }

    public void roundLoop_inverse(int time) {
        //ShiftRow_inverse();

        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = SubWord_inverse(State[k][j]);
            }
        }

        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = State[k][j] ^ extend_key[160 - time * 16 + i];
                i++;
            }
        }

        if (time != 10) {
            MixColumn_inverse();
        }
    }

    public void MixColumn_inverse() {
        int[][] temp = new int[4][4];
        for (int i = 0; i < 4; i++) {
            temp[0][i] = Multi(State[0][i], 14) ^ Multi(State[1][i], 11) ^
                    Multi(State[2][i], 13) ^ Multi(State[3][i], 9);
            temp[1][i] = Multi(State[0][i], 9) ^ Multi(State[1][i], 14) ^
                    Multi(State[2][i], 11) ^ Multi(State[3][i], 13);
            temp[2][i] = Multi(State[0][i], 13) ^ Multi(State[1][i], 9) ^
                    Multi(State[2][i], 14) ^ Multi(State[3][i], 11);
            temp[3][i] = Multi(State[0][i], 11) ^ Multi(State[1][i], 13) ^
                    Multi(State[2][i], 9) ^ Multi(State[3][i], 14);

        }

        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = temp[k][j];
            }
        }
    }

    public void getSlice(int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = codeNum[i];
                i++;
            }
        }
    }

    //start allocate to x-axis
    public void getSlicetoCubeX(int slice, int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                sliceState[slice][k][j] = codeNum[i];
                i++;
            }
        }
    }
    //end x-axis
    //start allocate to y-axis

    public void getSlicetoCubeY(int slice, int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                sliceState[k][slice][j] = codeNum[i];
                i++;
            }
        }
    }
    //end y-axis
    //start allocate to z-axis

    public void getSlicetoCubeZ(int slice, int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                sliceState[k][j][slice] = codeNum[i];
                i++;
            }
        }
    }
    //end z-axis

    public void getRotateSlice(int axis) {
        int i = 0;
        switch (axis) {
            case 0:
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        State[k][j] = sliceState[0][k][j];
                        i++;
                    }
                }
                break;
            case 1:
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        State[3 - j][k] = sliceState[1][k][j];
                        i++;
                    }
                }
                break;
            case 2:
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        State[3 - k][3 - j] = sliceState[2][k][j];
                        i++;
                    }
                }
                break;
            case 3:
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        State[j][3 - k] = sliceState[3][k][j];
                        i++;
                    }
                }
                break;
        }
    }

    public void outSlice(int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                codeNum[i] = State[k][j];
                i++;
            }
        }
    }

    public void outRotateSlice(int slice, int codeNum[]) {
        int i = 0;
        switch (slice) {
            case 0:
                for (int j = 0; j < 4; j++) {
                    for (int k = 0; k < 4; k++) {
                        codeNum[i] = State[k][j];
                        i++;
                    }
                }
                break;
            case 1:
                for (int j = 3; j >= 0; j--) {
                    for (int k = 0; k < 4; k++) {
                        codeNum[i] = State[j][k];
                        i++;
                    }
                }
                break;
            case 2:
                for (int j = 3; j >= 0; j--) {
                    for (int k = 3; k >= 0; k--) {
                        codeNum[i] = State[k][j];
                        i++;
                    }
                }
                break;
            case 3:
                for (int j = 0; j < 4; j++) {
                    for (int k = 3; k >= 0; k--) {
                        codeNum[i] = State[j][k];
                        i++;
                    }
                }
                break;

        }
    }

    public void outSlicetoCube(int slice, int codeNum[]) {
        int i = 0;
        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                sliceState[slice][k][j] = codeNum[i];
                i++;
            }
        }
    }

    public void getKey(int keyNum[]) {
        for (int i = 0; i < 16; i++) {
            key[i] = 0;
        }

        for (int j = 0; j < 4; j++) {
            for (int k = 0; k < 4; k++) {
                State[k][j] = 0;
            }
        }

        for (int i = 0; i < 16; i++) {
            key[i] = keyNum[i] ^ key[i];
        }
    }

    public void inEnX() {
        int KIRALOOPMSG = 0;
        int KIRALOOPMSGc = 0;
        int y, i, j;
        int[] codeNum = new int[16];

        int[] keyNum = new int[16];
        String tempKey = tempKeyD;
        String tempCode = tempCodeD;

        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();


        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0              ,j = 0; j < tempKey.length(); j++, i++) {
            KIRALOOPMSG++;
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }

        keyGeneration();

        /* if the keys are shorter or longer than 16 bits,it add '0' to the tail
         * until it mod(16) equals to 0
         */

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int s;
        float progress = tempCode.length();

        for (s = 0            ,y = 0            ,i = 0            ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }

            KIRALOOPMSGc++;
            codeNum[i] = (tempCode.charAt(j));

            if (i == 15) {
                switch (y) {
                    case 0:
                        getSlicetoCubeX(0, codeNum);
                        y++;
                        break;
                    case 1:
                        getSlicetoCubeX(1, codeNum);
                        ;
                        y++;
                        break;
                    case 2:
                        getSlicetoCubeX(2, codeNum);
                        ;
                        y++;
                        break;
                    case 3:
                        getSlicetoCubeX(3, codeNum);

                        y = 0;
                        s++;
                        for (int slice = 0; slice < 4; slice++) {
                            getRotateSlice(slice);
                            msgEncrypt();
                            outSlice(codeNum);

                            for (i = 0; i < 16; i++) {
                                outputc += Character.toChars(codeNum[i])[0];
                                outputh += hexFormat(codeNum[i]);
                            }
                        }
                        break;
                }
                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inDeX() {

        int x, i, j;
        int[] codeNum = new int[16];
        int[] keyNum = new int[16];

        String tempKey = tempKeyD;
        String tempCode = tempCodeD;
        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();
        //String output = "";

        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0                , j = 0; j < tempKey.length(); j++, i++) {
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }
        keyGeneration();

        /* get the code if the keys are shorter or longer than 16 bits,
        it add '0' to the tail until it mod(16) equals to 0*/

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int t = 0;
        float progress = tempCode.length();

        for (x = 0                ,i = 0                ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }
            codeNum[i] = (tempCode.charAt(j));

            if (i == 15) {
                getSlice(codeNum);
                msgDecrypt();


                switch (x) {
                    case 0:
                        outRotateSlice(0, codeNum);
                        outSlicetoCube(0, codeNum);
                        x++;
                        break;
                    case 1:
                        outRotateSlice(1, codeNum);
                        outSlicetoCube(1, codeNum);
                        x++;
                        break;
                    case 2:
                        outRotateSlice(2, codeNum);
                        outSlicetoCube(2, codeNum);
                        x++;
                        break;
                    case 3:
                        outRotateSlice(3, codeNum);
                        outSlicetoCube(3, codeNum);
                        for (int jj = 0; jj < 4; jj++) {
                            for (int kk = 0; kk < 4; kk++) {
                                for (int ll = 0; ll < 4; ll++) {
                                    outputc +=
                                            Character.toChars(sliceState[jj][ll][kk])[0];
                                }
                            }
                        }
                        x = 0;
                        break;
                }
                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inEnY() {
        int KIRALOOPMSG = 0;
        int KIRALOOPMSGc = 0;
        int y, i, j;
        int[] codeNum = new int[16];

        int[] keyNum = new int[16];
        String tempKey = tempKeyD;
        String tempCode = tempCodeD;

        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();

        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0                , j = 0; j < tempKey.length(); j++, i++) {
            KIRALOOPMSG++;
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }

        keyGeneration();

        /* if the keys are shorter or longer than 16 bits,it add '0' to the tail
         * until it mod(16) equals to 0
         */

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int s;
        float progress = tempCode.length();
        for (s = 0            ,y = 0            ,i = 0            ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }
            KIRALOOPMSGc++;
            codeNum[i] = (tempCode.charAt(j));

            if (i == 15) {
                switch (y) {
                    case 0:
                        getSlicetoCubeY(0, codeNum);
                        y++;
                        break;
                    case 1:
                        getSlicetoCubeY(1, codeNum);
                        ;
                        y++;
                        break;
                    case 2:
                        getSlicetoCubeY(2, codeNum);
                        ;
                        y++;
                        break;
                    case 3:
                        getSlicetoCubeY(3, codeNum);

                        y = 0;
                        s++;
                        for (int slice = 0; slice < 4; slice++) {
                            getRotateSlice(slice);
                            msgEncrypt();
                            outSlice(codeNum);

                            for (i = 0; i < 16; i++) {
                                outputc += Character.toChars(codeNum[i])[0];
                                outputh += hexFormat(codeNum[i]);
                            }
                        }
                        break;
                }

                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inDeY() {
        int x, i, j;
        int[] codeNum = new int[16];
        int[] keyNum = new int[16];
        String tempKey = tempKeyD;
        String tempCode = tempCodeD;
        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();


        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0                , j = 0; j < tempKey.length(); j++, i++) {
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }
        keyGeneration();

        /* get the code if the keys are shorter or longer than 16 bits,
        it add '0' to the tail until it mod(16) equals to 0*/

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int t = 0;
        float progress = tempCode.length();

        for (x = 0                ,i = 0                ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }
            codeNum[i] = (tempCode.charAt(j));

            if (i == 15) {
                getSlice(codeNum);
                msgDecrypt();

                switch (x) {
                    case 0:
                        outRotateSlice(0, codeNum);
                        outSlicetoCube(0, codeNum);
                        x++;
                        break;
                    case 1:
                        outRotateSlice(1, codeNum);
                        outSlicetoCube(1, codeNum);
                        x++;
                        break;
                    case 2:
                        outRotateSlice(2, codeNum);
                        outSlicetoCube(2, codeNum);
                        x++;
                        break;
                    case 3:
                        outRotateSlice(3, codeNum);
                        outSlicetoCube(3, codeNum);
                        for (int jj = 0; jj < 4; jj++) {
                            for (int kk = 0; kk < 4; kk++) {
                                for (int ll = 0; ll < 4; ll++) {
                                    outputc +=
                                            Character.toChars(sliceState[ll][jj][kk])[0];
                                }
                            }
                        }
                        x = 0;
                        break;
                }
                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inEnZ() {
        int KIRALOOPMSG = 0;
        int KIRALOOPMSGc = 0;
        int y, i, j;
        int[] codeNum = new int[16];

        int[] keyNum = new int[16];
        String tempKey = tempKeyD;
        String tempCode = tempCodeD;

        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();

        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0                , j = 0; j < tempKey.length(); j++, i++) {
            KIRALOOPMSG++;
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }

        keyGeneration();

        /* if the keys are shorter or longer than 16 bits,it add '0' to the tail
         * until it mod(16) equals to 0
         */

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int s;
        float progress = tempCode.length();

        for (s = 0              ,y = 0              ,i = 0              ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }
            KIRALOOPMSGc++;
            codeNum[i] = (tempCode.charAt(j));

            if (i == 15) {
                switch (y) {
                    case 0:
                        getSlicetoCubeZ(0, codeNum);
                        y++;
                        break;
                    case 1:
                        getSlicetoCubeZ(1, codeNum);
                        ;
                        y++;
                        break;
                    case 2:
                        getSlicetoCubeZ(2, codeNum);
                        ;
                        y++;
                        break;
                    case 3:
                        getSlicetoCubeZ(3, codeNum);


                        y = 0;
                        s++;
                        for (int slice = 0; slice < 4; slice++) {
                            getRotateSlice(slice);
                            msgEncrypt();
                            outSlice(codeNum);
                            for (i = 0; i < 16; i++) {
                                outputc += Character.toChars(codeNum[i])[0];
                                outputh += hexFormat(codeNum[i]);
                            }
                        }
                        break;
                }
                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inDeZ() {
        int x, i, j;
        int[] codeNum = new int[16];
        int[] keyNum = new int[16];
        String tempKey = tempKeyD;
        String tempCode = tempCodeD;
        int lengthKey = tempKey.length();
        int lengthCode = tempCode.length();
        String output = "";

        if (lengthKey % 16 != 0) {
            for (i = lengthKey % 16; i < 16; i++) {
                tempKey += " ";
            }
        }

        for (i = 0              , j = 0; j < tempKey.length(); j++, i++) {
            keyNum[i] = tempKey.charAt(i);
            if (i == 15) {
                getKey(keyNum);
                i = -1;
            }
        }
        keyGeneration();

        /* get the code if the keys are shorter or longer than 16 bits,
        it add '0' to the tail until it mod(16) equals to 0*/

        if (lengthCode % 64 != 0) {
            for (i = lengthCode % 64; i < 64; i++) {
                tempCode += " ";
            }
        }
        int t = 0;
        float progress = tempCode.length();

        for (x = 0              ,i = 0              ,j = 0; j < tempCode.length(); j++, i++) {
            if ((j % 5) == 1) {
                displayProgress((int) ((j / progress) * 100));
            }
            codeNum[i] = (tempCode.charAt(j));
            if (i == 15) {
                getSlice(codeNum);
                msgDecrypt();

                switch (x) {
                    case 0:
                        outRotateSlice(0, codeNum);
                        outSlicetoCube(0, codeNum);
                        x++;
                        break;
                    case 1:
                        outRotateSlice(1, codeNum);
                        outSlicetoCube(1, codeNum);
                        x++;
                        break;
                    case 2:
                        outRotateSlice(2, codeNum);
                        outSlicetoCube(2, codeNum);
                        x++;
                        break;
                    case 3:
                        outRotateSlice(3, codeNum);
                        outSlicetoCube(3, codeNum);
                        for (int jj = 0; jj < 4; jj++) {
                            for (int kk = 0; kk < 4; kk++) {
                                for (int ll = 0; ll < 4; ll++) {
                                    outputc +=
                                            Character.toChars(sliceState[ll][kk][jj])[0];
                                }
                            }
                        }
                        x = 0;
                        break;
                }
                i = -1;
            }
        }
        displayProgress((int) ((j / progress) * 100));
    }

    public void inEnData() {
        tempKeyD = inKTextField.getText();
        tempCodeD = inPTextArea.getText();
        inProgressTextArea.setText("");
        outputh = "";
        outputc = "";
    }

    public void outEnData() {
        inEnTextArea.setText(outputh);
        inTempTextArea.setText(outputc);
    }

    public void inDeData() {
        tempKeyD = inKTextField.getText();
        tempCodeD = inTempTextArea.getText();
        inProgressTextArea.setText("");
        outputc = "";
    }

    public void outDeData() {
        inDeTextArea.setText(outputc);
    }

    public void fEnData() {
        tempKeyD = fKTextArea.getText();
        tempCodeD = fPTextArea.getText();
        fProgressTextArea.setText("");
        outputh = "";
        outputc = "";
    }

    public void fDeData() {
        tempKeyD = fKTextArea.getText();
        tempCodeD = convertHexToString(fPTextArea.getText());
        inProgressTextArea.setText("");
        outputc = "";
    }

    public void displayProgress(int pL) {
        if (tabFlag == 1) {
            inProgressTextArea.append(String.format(
                    "Completed %d%% of task.\n", pL));
        } else if (tabFlag == 2) {
            fProgressTextArea.append(String.format(
                    "Completed %d%% of task.\n", pL));
        }
    }

    private void inExitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inExitButtonActionPerformed
        System.exit(0);
    }//GEN-LAST:event_inExitButtonActionPerformed

    private void inClearButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inClearButtonActionPerformed
        inPTextArea.setText("");
        inKTextField.setText("");
        inEnTextArea.setText("");
        inDeTextArea.setText("");
        inProgressTextArea.setText("");
    }//GEN-LAST:event_inClearButtonActionPerformed

    private void inStartButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inStartButtonActionPerformed
        final String commandF = buttonGroup1.getSelection().getActionCommand();
        final String commandR = buttonGroup2.getSelection().getActionCommand();
        tabFlag = 1;
        if (commandF.equals("en")) {
            inEnData();
            if (commandR.equals("xaxis")) {
                inEnX();
            } else if (commandR.equals("yaxis")) {
                inEnY();
            } else if (commandR.equals("zaxis")) {
                inEnZ();
            }
            outEnData();
        } else if (commandF.equals("de")) {
            inDeData();
            if (commandR.equals("xaxis")) {
                inDeX();
            } else if (commandR.equals("yaxis")) {
                inDeY();
            } else if (commandR.equals("zaxis")) {
                inDeZ();
            }
            outDeData();
        }
    }//GEN-LAST:event_inStartButtonActionPerformed

    private void fBrowseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fBrowseButtonActionPerformed

        int returnVal = fFileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fFileChooser.getSelectedFile();
            try {
                // What to do with the file, e.g. display it in a TextArea
                fPTextArea.read(new FileReader(file.getAbsolutePath()), null);
                fBrowseTextField.setText(file.getPath());
            } catch (IOException ex) {
                fPMsgLabel.setText("problem accessing file" + file.getAbsolutePath());
            }
        } else {
            fPMsgLabel.setText("File access cancelled by user.");
        }
    }//GEN-LAST:event_fBrowseButtonActionPerformed

    private void fStartButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fStartButtonActionPerformed
        final String commandF = buttonGroup3.getSelection().getActionCommand();
        final String commandR = buttonGroup4.getSelection().getActionCommand();
        tabFlag = 2;
        if (commandF.equals("en")) {
            fEnData();
            if (commandR.equals("xaxis")) {
                inEnX();
            } else if (commandR.equals("yaxis")) {
                inEnY();
            } else if (commandR.equals("zaxis")) {
                inEnZ();
            }
        } else if (commandF.equals("de")) {
            fDeData();
            if (commandR.equals("xaxis")) {
                inDeX();
            } else if (commandR.equals("yaxis")) {
                inDeY();
            } else if (commandR.equals("zaxis")) {
                inDeZ();
            }
        }
}//GEN-LAST:event_fStartButtonActionPerformed

    private void fClearButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fClearButtonActionPerformed
        fBrowseTextField.setText("");
        fKBrowseTextField.setText("");
        fEnTextField.setText("");
        fEnTextFieldC.setText("");
        fProgressTextArea.setText("");
}//GEN-LAST:event_fClearButtonActionPerformed

    private void fExitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fExitButtonActionPerformed
        System.exit(0);
}//GEN-LAST:event_fExitButtonActionPerformed
//private PrintWriter fileOutput;
    private void fEnSaveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fEnSaveButtonActionPerformed
        int returnVal = fFileChooser.showSaveDialog(mainFrame.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fFileChooser.getSelectedFile();
            try {
                // What to do with the file, e.g. display it in a TextArea
                BufferedWriter fileOutput = new BufferedWriter(new FileWriter(file));
                fEnTextField.setText(file.getPath());
                fileOutput.write(outputh);
                fileOutput.close();
            } catch (IOException ex) {
                fPMsgLabel.setText("problem accessing file" + file.getAbsolutePath());
            }
        } else {
            fPMsgLabel.setText("Save command cancelled by user.");
        }
        fPMsgLabel.setCaretPosition(fPMsgLabel.getDocument().getLength());
        outputh = "";
}//GEN-LAST:event_fEnSaveButtonActionPerformed

    private void fKBrowseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fKBrowseButtonActionPerformed
        int returnVal = fFileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fFileChooser.getSelectedFile();
            try {
                // What to do with the file, e.g. display it in a TextArea
                fKTextArea.read(new FileReader(file.getAbsolutePath()), null);
                fKBrowseTextField.setText(file.getPath());
            } catch (IOException ex) {
                fKMsgLabel.setText("problem accessing file" + file.getAbsolutePath());
            }
        } else {
            fKMsgLabel.setText("File access cancelled by user.");
        }
    }//GEN-LAST:event_fKBrowseButtonActionPerformed

    private void fEnSaveButtonCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fEnSaveButtonCActionPerformed
        int returnVal = fFileChooser.showSaveDialog(mainFrame.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fFileChooser.getSelectedFile();
            try {
                // What to do with the file, e.g. display it in a TextArea
                BufferedWriter fileOutput = new BufferedWriter(new FileWriter(file));
                fEnTextFieldC.setText(file.getPath());
                fileOutput.write(outputc);

                fileOutput.close();
            } catch (IOException ex) {
                fPMsgLabel.setText("problem accessing file" + file.getAbsolutePath());
            }
        } else {
            fPMsgLabel.setText("Save command cancelled by user.");
        }
        fPMsgLabel.setCaretPosition(fPMsgLabel.getDocument().getLength());
        outputc = "";
}//GEN-LAST:event_fEnSaveButtonCActionPerformed

    private void helpPanelAncestorAdded(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_helpPanelAncestorAdded
        helpTextArea.append("Author by : Suriyani Ariffin\n");
        helpTextArea.append("year: 2010-2012\n");
        helpTextArea.append("Phd Title : 3D-AES block cipher\n");
        helpTextArea.append("e-mail: suriyani@tmsk.uitm.edu.my\n");
       

}//GEN-LAST:event_helpPanelAncestorAdded

    private void page1ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_page1ButtonActionPerformed
        try {
            BufferedImage image = ImageIO.read(new File("helppage1.png"));
            dImage imp = new dImage(image);
            JFrame helpFrame = new JFrame("Page 1: Help for Input from Text");
            helpFrame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
            helpFrame.add(imp);
            helpFrame.setSize(600, 460);
            helpFrame.setLocation(10, 10);
            helpFrame.setVisible(true);
        } catch (IOException ie) {
            System.out.println("Error:" + ie.getMessage());
        }
    }//GEN-LAST:event_page1ButtonActionPerformed

    private void page2ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_page2ButtonActionPerformed
        try {
            BufferedImage image = ImageIO.read(new File("helppage2.png"));
            dImage imp = new dImage(image);
            JFrame helpFrame = new JFrame("Page 2: Help for Input from File");
            //helpFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            helpFrame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
            helpFrame.add(imp);
            helpFrame.setSize(600, 460);
            helpFrame.setLocation(10, 10);
            helpFrame.setVisible(true);
        } catch (IOException ie) {
            System.out.println("Error:" + ie.getMessage());
        }
    }//GEN-LAST:event_page2ButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new mainFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private javax.swing.ButtonGroup buttonGroup4;
    private javax.swing.JButton fBrowseButton;
    private javax.swing.JTextField fBrowseTextField;
    private javax.swing.JLayeredPane fCLPane;
    private javax.swing.JButton fClearButton;
    private javax.swing.JRadioButton fDeRadioButton;
    private javax.swing.JLabel fEnNameLabel;
    private javax.swing.JLabel fEnNameLabelC;
    private javax.swing.JRadioButton fEnRadioButton;
    private javax.swing.JButton fEnSaveButton;
    private javax.swing.JButton fEnSaveButtonC;
    private javax.swing.JTextField fEnTextField;
    private javax.swing.JTextField fEnTextFieldC;
    private javax.swing.JButton fExitButton;
    private javax.swing.JLayeredPane fFLPane;
    private javax.swing.JFileChooser fFileChooser;
    private javax.swing.JLabel fFileNameLabel;
    private javax.swing.JButton fKBrowseButton;
    private javax.swing.JTextField fKBrowseTextField;
    private javax.swing.JTextField fKMsgLabel;
    private javax.swing.JTextArea fKTextArea;
    private javax.swing.JLabel fKeyNameLabel;
    private javax.swing.JLayeredPane fPLPane;
    private javax.swing.JTextField fPMsgLabel;
    private javax.swing.JTextArea fPTextArea;
    private javax.swing.JLayeredPane fProgressLPane;
    private javax.swing.JTextArea fProgressTextArea;
    private javax.swing.JLayeredPane fRotateLPane1;
    private javax.swing.JButton fStartButton;
    private javax.swing.JTextArea fTempTextArea;
    private javax.swing.JRadioButton fxAxisRadioButton;
    private javax.swing.JRadioButton fyAxisRadioButton;
    private javax.swing.JRadioButton fzAxisRadioButton;
    private javax.swing.JPanel helpPanel;
    private javax.swing.JTextArea helpTextArea;
    private javax.swing.JButton inClearButton;
    private javax.swing.JLayeredPane inDeLPane;
    private javax.swing.JRadioButton inDeRadioButton;
    private javax.swing.JTextArea inDeTextArea;
    private javax.swing.JLayeredPane inEnLPane;
    private javax.swing.JRadioButton inEnRadioButton;
    private javax.swing.JTextArea inEnTextArea;
    private javax.swing.JButton inExitButton;
    private javax.swing.JLayeredPane inFLPane;
    private javax.swing.JLayeredPane inKLPane;
    private javax.swing.JTextField inKTextField;
    private javax.swing.JLayeredPane inPLPane;
    private javax.swing.JTextArea inPTextArea;
    private javax.swing.JLayeredPane inProgressLPane;
    private javax.swing.JTextArea inProgressTextArea;
    private javax.swing.JLayeredPane inRotateLPane;
    private javax.swing.JButton inStartButton;
    private javax.swing.JTextArea inTempTextArea;
    private javax.swing.JPanel inputFilePanel;
    private javax.swing.JTabbedPane inputFileTab;
    private javax.swing.JPanel inputTextPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane10;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JScrollPane jScrollPane8;
    private javax.swing.JScrollPane jScrollPane9;
    private javax.swing.JButton page1Button;
    private javax.swing.JButton page2Button;
    private javax.swing.JRadioButton xAxisRadioButton;
    private javax.swing.JRadioButton yAxisRadioButton;
    private javax.swing.JRadioButton zAxisRadioButton;
    // End of variables declaration//GEN-END:variables
}
